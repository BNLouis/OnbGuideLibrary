{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Welcome to the OpenNetBattle engine. This document will provide some beginner tutorials for content creation on ONB for all of the main types of mods. Mods ONB currently has 4 types of mods. Players: These are the navi mods you play as. Their sprites are entirely customizable and you can even script your own moves. Cards: These are equivalent to battlechips and allow the user to perform actions. Blocks: These are \"navicust\" blocks used to give your navi buffs. Enemies: These are enemies and bosses that can be fought. There is a debug mode where these can be fought, and server creators can use these for encounters on their servers.","title":"Introduction"},{"location":"#introduction","text":"Welcome to the OpenNetBattle engine. This document will provide some beginner tutorials for content creation on ONB for all of the main types of mods.","title":"Introduction"},{"location":"#mods","text":"ONB currently has 4 types of mods. Players: These are the navi mods you play as. Their sprites are entirely customizable and you can even script your own moves. Cards: These are equivalent to battlechips and allow the user to perform actions. Blocks: These are \"navicust\" blocks used to give your navi buffs. Enemies: These are enemies and bosses that can be fought. There is a debug mode where these can be fought, and server creators can use these for encounters on their servers.","title":"Mods"},{"location":"adding_mod/","text":"","title":"Adding mod"},{"location":"animations/","text":".animation files .animation files are files used by the engine to animate textures. They can be opened in any text editor. If you want to use a graphical user interface to build animations you can use Keristero\u2019s sprite tool , but read on if you want to know the technical details. Animation files will have one or more animation states defined in them. animation state=\"IDLE_U\" animation : Indicates the start of a new animation state : Name of the animation, in this case IDLE_U. If its a player animation, you'll need to use the standard player states. frame duration=\"0.05\" x=\"0\" y=\"0\" w=\"100\" h=\"100\" originx=\"50\" originy=\"100\" flipx=\"1\" flipy=\"0\" frame : Indicates a new frame in the animation. Must come after an animation state duration : The amount of time in seconds to hold the frame x : Starting point on the sheet for the upper left corner of your sprite\u2019s x y : Starting point on the sheet for the upper left corner of your sprite\u2019s y w : Width of the frame h : Height of the frame originy : y coordinate within the frame, used to align the placement of the frame originx : x coordinate within the frame, used to align the placement of the frame flipy : Flip along the y axis 0=false 1=true. Optional flipx : Flip along the x axis 0=false 1=true. Optional flipx and flipy are not required but can be useful to cut down on workload for sprites that can be flipped! point label=\"Head\" x=\"29\" y=\"13\" point : Used to assign overlay points. Zero or more can be defined for a frame. Must come after a frame label : Name of the point. See Battle Animations for points used by battles","title":".animation files"},{"location":"animations/#animation-files","text":".animation files are files used by the engine to animate textures. They can be opened in any text editor. If you want to use a graphical user interface to build animations you can use Keristero\u2019s sprite tool , but read on if you want to know the technical details. Animation files will have one or more animation states defined in them. animation state=\"IDLE_U\" animation : Indicates the start of a new animation state : Name of the animation, in this case IDLE_U. If its a player animation, you'll need to use the standard player states. frame duration=\"0.05\" x=\"0\" y=\"0\" w=\"100\" h=\"100\" originx=\"50\" originy=\"100\" flipx=\"1\" flipy=\"0\" frame : Indicates a new frame in the animation. Must come after an animation state duration : The amount of time in seconds to hold the frame x : Starting point on the sheet for the upper left corner of your sprite\u2019s x y : Starting point on the sheet for the upper left corner of your sprite\u2019s y w : Width of the frame h : Height of the frame originy : y coordinate within the frame, used to align the placement of the frame originx : x coordinate within the frame, used to align the placement of the frame flipy : Flip along the y axis 0=false 1=true. Optional flipx : Flip along the x axis 0=false 1=true. Optional flipx and flipy are not required but can be useful to cut down on workload for sprites that can be flipped! point label=\"Head\" x=\"29\" y=\"13\" point : Used to assign overlay points. Zero or more can be defined for a frame. Must come after a frame label : Name of the point. See Battle Animations for points used by battles","title":".animation files"},{"location":"blocks/","text":"Under Construction","title":"Blocks"},{"location":"cards/","text":"Chips Guide Welcome to the first ONB chip making guide. In this tutorial we will be walking through the code of AirToss, a custom chip. This is a simple chip that sends out a tornado through the row and deals damage to entity it hits. The hit entity is also pushed back one tile. See the mod thread on discord for example video. The Directory Setup The directory of the chip is set up as the following. You'll see all the sounds, code and textures the chip needs. effect.animation : The effect .animation file needed by the effect texture to properly animate effect.png : This image actually contains all of the textures and is used alongside effect.animation to display effects on the screen. entry.lua : The main entry point to the mod. Contains all of the lua code. icon.png : This is the small chip icon that appears above your head in battle, or when selecting chips. preview.png : This is the larger chip icon that is also shown ingame. tornado.animation : Same as effect.animation, except for the tornado effect. torando.png : Same as tornado.png except for the tornado effect. These resource can either be created manually or obtained from the discord. Entry.lua Entry.lua is the heart of the mod and every mod must have a file named entry.lua as that is the file the engine will look at first. We'll go through most of the code so you can have an idea of how chip mods are structured. Any line that starts with -- is a comment, and is completely ignored by the engine, and is there soley for the reader's information. Resource loading First, the textures, sounds and animations the chip uses should be loaded. The variable _modpath used in these functions refers to the mod folder. Textures and sounds must be loaded with Engine.load_audio or Engine.load_texture , but animations do not need to be. --- Custom Chip: Tornado Toss --- Setup Textures, Animations and Sounds --- modpath refers to the root folder of the chip. TORNADO_TEXTURE = Engine . load_texture ( _modpath .. \"tornado.png\" ) TORNADO_ANIMATION = _modpath .. \"tornado.animation\" WIND_SFX = Engine . load_audio ( _modpath .. \"tornado.ogg\" ) HIT_TEXTURE = Engine . load_texture ( _modpath .. \"effect.png\" ) HIT_ANIM_PATH = _modpath .. \"effect.animation\" HIT_SOUND = Engine . load_audio ( _modpath .. \"hitsound.ogg\" ) Next, you'll notice a DAMAGE variable. This is referenced later on to set the displayed damage on this chip as well as the actual damage of the spell. --Damage property. DAMAGE = 90 After that is the package_init, which has been commented with what each line does. Package_init is a required function in card mods. Package Init function package_init ( package ) local props = package : get_card_props () --standard properties -- DisplayName of the chip props . shortname = \"AirToss\" -- Damage displayed on the chip props . damage = DAMAGE -- Whether or not this chip uses time freeze. props . time_freeze = false -- Element displayed on this chip. props . element = Element . Wind -- Description of this chip in the folder props . description = \"Throws a tornado forward!\" -- Description of this chip when special button is presssed props . long_description = \"Throws a tornado that pushes forward!\" -- Package ID. Usually uses some form of the author's name + chip name package : declare_package_id ( \"com.louise.\" .. props . shortname ) -- Sets small icon icon package : set_icon_texture ( Engine . load_texture ( _modpath .. \"icon.png\" )) -- Sets large preview graphic package : set_preview_texture ( Engine . load_texture ( _modpath .. \"preview.png\" )) -- List of codes this chip will be available as. package : set_codes ({ \"A\" , \"I\" , \"R\" , \"*\" }) end Card Create Action Card create action is where most of the action happens. You\u2019ll see that a reference to the player is passed into this function as well as the card props we previously defined. Card create action handles setting up the player's animation and defining what happens during the frames of that animation. In this case, we are using the PLAYER_SWORD animation, but showing the navi's hand instead of a sword, which is common for these types of \"summon\" spells. function card_create_action ( user , props ) -- Creates a new cardAction that will play the play_sword animation local action = Battle . CardAction . new ( user , \"PLAYER_SWORD\" ) -- Prevents the user from using other cards during this animation action : set_lockout ( make_animation_lockout ()) --Function that happens when the card actually executes. action . execute_func = function ( self , user ) local actor = self : get_actor () -- set:add_anim_action adds functions that execute on certain frames of the -- action animation. self : add_anim_action ( 1 , function () -- Allows the action to be countered during this window. actor : toggle_counter ( true ) end ) self : add_anim_action ( 2 , function () -- Necessary code to render the hand of the user local hilt = self : add_attachment ( \"HILT\" ) local hilt_sprite = hilt : sprite () hilt_sprite : set_texture ( actor : get_texture ()) hilt_sprite : set_layer ( - 2 ) hilt_sprite : enable_parent_shader ( true ) local hilt_anim = hilt : get_animation () hilt_anim : copy_from ( actor : get_animation ()) hilt_anim : set_state ( \"HAND\" ) hilt_anim : refresh ( hilt_sprite ) -- Get the current local direction = user : get_facing () -- Play the wind effect defined earlier Engine . play_audio ( WIND_SFX , AudioPriority . High ) -- Now control will be handed over to the create_tornado function. -- Variables that are needed by that function are passed in here. create_tornado ( user , user : get_tile ( direction , 1 ), DAMAGE , 10 , direction ) end ) self : add_anim_action ( 3 , function () end ) self : add_anim_action ( 4 , function () -- End the counterable window user : toggle_counter ( false ) end ) end return action end Create Tornado Function To improve readability of the code, we created another function for handling the tornado spell. Notes: Spell:set_hit_props takes in a HitProps object. This is where you can define the damage, element and additional properties. In this case our spell will have the following properties: Damage: set to 90, due to the variable we passed in. Hit.Impact A necessary property for most spell respects barriers, etc. Hit.Flash This spell will grant the target temporary invincibility after hitting it. Hit.Flinch This spell will flinch the target, playing its hurt animation and cancelling its current action. Hit.Drag This property is necessary to enable the spell to push a target. Drag.new(direction, 1) This moves the target in the given direction by one tile. Full set of hit props is listed at the api site . ---@param user Entity The user summoning a tornado ---@param tile Tile The tile to summon the tornado on ---@param damage number The amount of damage the tornado will do ---@param speed number The number of frames it takes the tornado to travel 1 tile. ---@param direction any The direction the spell is travelling function create_tornado ( user , tile , damage , speed , direction ) -- Creates a new spell that belongs to the user's team. local spell = Battle . Spell . new ( user : get_team ()) --Set the hit properties of this spell. spell : set_hit_props ( HitProps . new ( damage , Hit . Impact | Hit . Flash | Hit . Flinch | Hit . Drag , Element . Wind , user : get_context (), Drag . new ( direction , 1 ) ) ) -- Setup sprite of the spell local sprite = spell : sprite () sprite : set_texture ( TORNADO_TEXTURE ) sprite : set_layer ( - 1 ) -- Setup animation of the spell local anim = spell : get_animation () anim : load ( TORNADO_ANIMATION ) anim : set_state ( \"1\" ) anim : set_playback ( Playback . Loop ) anim : refresh ( sprite ) spell . update_func = function ( self , dt ) --- Gets the next tile in the specified direction. --- If that tile is out of bounds, it returns nil local tile = spell : get_tile ( direction , 1 ) if ( tile == nil ) then -- Spell will be erased once it reaches the end of the field. spell : erase () return end --- Makes the spell slide to the next tile over a certain number of frames. spell : slide ( tile , frames ( speed ), frames ( 0 ), ActionOrder . Voluntary , nil ) --- Attacks the entities this spell collides with. self : get_current_tile (): attack_entities ( self ) end spell . attack_func = function ( self , other ) -- Erases the spell once it hits something create_hit_effect ( spell : get_field (), spell : get_current_tile (), HIT_TEXTURE , HIT_ANIM_PATH , \"8\" , HIT_SOUND ) spell : erase () end spell . delete_func = function ( self ) spell : erase () end spell . battle_end_func = function ( self ) spell : erase () end --- Function that decides whether or not this spell is allowed --- to move to a certain tile. This is automatically called for --- functions such as slide and teleport. --- In this case since it always returns true, it can move over --- any tile. spell . can_move_to_func = function ( tile ) return true end user : get_field (): spawn ( spell , tile ) return spell end Create Hit Effect Function Lastly, for BN accuracy, we have the hit effect function. This spawns an artifact, which is a sort of texture and animation that does not interact with entities. Most spells have an impact effect, which is what this function is doing. --- create hit effect. ---@param field any #A field to spawn the effect on ---@param tile Tile tile to spawn effect on ---@param hit_texture any Texture hit effect. (Engine.load_texture) ---@param hit_anim_path any The animation file path ---@param hit_anim_state any The hit animation to play ---@param sfx any Audio # Audio object to play ---@return any returns the hit fx function create_hit_effect ( field , tile , hit_texture , hit_anim_path , hit_anim_state , sfx ) -- Create artifact, artifacts do not have hitboxes and are used mostly for special effects local hitfx = Battle . Artifact . new () hitfx : set_texture ( hit_texture , true ) -- This will randomize the position of the effect a bit. hitfx : set_offset ( math.random ( - 25 , 25 ), math.random ( - 25 , 25 )) local hitfx_sprite = hitfx : sprite () hitfx_sprite : set_layer ( - 3 ) local hitfx_anim = hitfx : get_animation () hitfx_anim : load ( hit_anim_path ) hitfx_anim : set_state ( hit_anim_state ) hitfx_anim : refresh ( hitfx_sprite ) hitfx_anim : on_frame ( 1 , function () Engine . play_audio ( sfx , AudioPriority . Highest ) end ) hitfx_anim : on_complete ( function () hitfx : erase () end ) field : spawn ( hitfx , tile ) return hitfx end Next Steps Now that you have some familiarity with how a chip is laid out, the possiblities are endless. Want to make a fire tornado with 120 damage? Want to throw a totally new custom spell? If you can create the art for it, now you can!","title":"Chips Guide"},{"location":"cards/#chips-guide","text":"Welcome to the first ONB chip making guide. In this tutorial we will be walking through the code of AirToss, a custom chip. This is a simple chip that sends out a tornado through the row and deals damage to entity it hits. The hit entity is also pushed back one tile. See the mod thread on discord for example video.","title":"Chips Guide"},{"location":"cards/#the-directory-setup","text":"The directory of the chip is set up as the following. You'll see all the sounds, code and textures the chip needs. effect.animation : The effect .animation file needed by the effect texture to properly animate effect.png : This image actually contains all of the textures and is used alongside effect.animation to display effects on the screen. entry.lua : The main entry point to the mod. Contains all of the lua code. icon.png : This is the small chip icon that appears above your head in battle, or when selecting chips. preview.png : This is the larger chip icon that is also shown ingame. tornado.animation : Same as effect.animation, except for the tornado effect. torando.png : Same as tornado.png except for the tornado effect. These resource can either be created manually or obtained from the discord.","title":"The Directory Setup"},{"location":"cards/#entrylua","text":"Entry.lua is the heart of the mod and every mod must have a file named entry.lua as that is the file the engine will look at first. We'll go through most of the code so you can have an idea of how chip mods are structured. Any line that starts with -- is a comment, and is completely ignored by the engine, and is there soley for the reader's information.","title":"Entry.lua"},{"location":"cards/#resource-loading","text":"First, the textures, sounds and animations the chip uses should be loaded. The variable _modpath used in these functions refers to the mod folder. Textures and sounds must be loaded with Engine.load_audio or Engine.load_texture , but animations do not need to be. --- Custom Chip: Tornado Toss --- Setup Textures, Animations and Sounds --- modpath refers to the root folder of the chip. TORNADO_TEXTURE = Engine . load_texture ( _modpath .. \"tornado.png\" ) TORNADO_ANIMATION = _modpath .. \"tornado.animation\" WIND_SFX = Engine . load_audio ( _modpath .. \"tornado.ogg\" ) HIT_TEXTURE = Engine . load_texture ( _modpath .. \"effect.png\" ) HIT_ANIM_PATH = _modpath .. \"effect.animation\" HIT_SOUND = Engine . load_audio ( _modpath .. \"hitsound.ogg\" ) Next, you'll notice a DAMAGE variable. This is referenced later on to set the displayed damage on this chip as well as the actual damage of the spell. --Damage property. DAMAGE = 90 After that is the package_init, which has been commented with what each line does. Package_init is a required function in card mods.","title":"Resource loading"},{"location":"cards/#package-init","text":"function package_init ( package ) local props = package : get_card_props () --standard properties -- DisplayName of the chip props . shortname = \"AirToss\" -- Damage displayed on the chip props . damage = DAMAGE -- Whether or not this chip uses time freeze. props . time_freeze = false -- Element displayed on this chip. props . element = Element . Wind -- Description of this chip in the folder props . description = \"Throws a tornado forward!\" -- Description of this chip when special button is presssed props . long_description = \"Throws a tornado that pushes forward!\" -- Package ID. Usually uses some form of the author's name + chip name package : declare_package_id ( \"com.louise.\" .. props . shortname ) -- Sets small icon icon package : set_icon_texture ( Engine . load_texture ( _modpath .. \"icon.png\" )) -- Sets large preview graphic package : set_preview_texture ( Engine . load_texture ( _modpath .. \"preview.png\" )) -- List of codes this chip will be available as. package : set_codes ({ \"A\" , \"I\" , \"R\" , \"*\" }) end","title":"Package Init"},{"location":"cards/#card-create-action","text":"Card create action is where most of the action happens. You\u2019ll see that a reference to the player is passed into this function as well as the card props we previously defined. Card create action handles setting up the player's animation and defining what happens during the frames of that animation. In this case, we are using the PLAYER_SWORD animation, but showing the navi's hand instead of a sword, which is common for these types of \"summon\" spells. function card_create_action ( user , props ) -- Creates a new cardAction that will play the play_sword animation local action = Battle . CardAction . new ( user , \"PLAYER_SWORD\" ) -- Prevents the user from using other cards during this animation action : set_lockout ( make_animation_lockout ()) --Function that happens when the card actually executes. action . execute_func = function ( self , user ) local actor = self : get_actor () -- set:add_anim_action adds functions that execute on certain frames of the -- action animation. self : add_anim_action ( 1 , function () -- Allows the action to be countered during this window. actor : toggle_counter ( true ) end ) self : add_anim_action ( 2 , function () -- Necessary code to render the hand of the user local hilt = self : add_attachment ( \"HILT\" ) local hilt_sprite = hilt : sprite () hilt_sprite : set_texture ( actor : get_texture ()) hilt_sprite : set_layer ( - 2 ) hilt_sprite : enable_parent_shader ( true ) local hilt_anim = hilt : get_animation () hilt_anim : copy_from ( actor : get_animation ()) hilt_anim : set_state ( \"HAND\" ) hilt_anim : refresh ( hilt_sprite ) -- Get the current local direction = user : get_facing () -- Play the wind effect defined earlier Engine . play_audio ( WIND_SFX , AudioPriority . High ) -- Now control will be handed over to the create_tornado function. -- Variables that are needed by that function are passed in here. create_tornado ( user , user : get_tile ( direction , 1 ), DAMAGE , 10 , direction ) end ) self : add_anim_action ( 3 , function () end ) self : add_anim_action ( 4 , function () -- End the counterable window user : toggle_counter ( false ) end ) end return action end","title":"Card Create Action"},{"location":"cards/#create-tornado-function","text":"To improve readability of the code, we created another function for handling the tornado spell. Notes: Spell:set_hit_props takes in a HitProps object. This is where you can define the damage, element and additional properties. In this case our spell will have the following properties: Damage: set to 90, due to the variable we passed in. Hit.Impact A necessary property for most spell respects barriers, etc. Hit.Flash This spell will grant the target temporary invincibility after hitting it. Hit.Flinch This spell will flinch the target, playing its hurt animation and cancelling its current action. Hit.Drag This property is necessary to enable the spell to push a target. Drag.new(direction, 1) This moves the target in the given direction by one tile. Full set of hit props is listed at the api site . ---@param user Entity The user summoning a tornado ---@param tile Tile The tile to summon the tornado on ---@param damage number The amount of damage the tornado will do ---@param speed number The number of frames it takes the tornado to travel 1 tile. ---@param direction any The direction the spell is travelling function create_tornado ( user , tile , damage , speed , direction ) -- Creates a new spell that belongs to the user's team. local spell = Battle . Spell . new ( user : get_team ()) --Set the hit properties of this spell. spell : set_hit_props ( HitProps . new ( damage , Hit . Impact | Hit . Flash | Hit . Flinch | Hit . Drag , Element . Wind , user : get_context (), Drag . new ( direction , 1 ) ) ) -- Setup sprite of the spell local sprite = spell : sprite () sprite : set_texture ( TORNADO_TEXTURE ) sprite : set_layer ( - 1 ) -- Setup animation of the spell local anim = spell : get_animation () anim : load ( TORNADO_ANIMATION ) anim : set_state ( \"1\" ) anim : set_playback ( Playback . Loop ) anim : refresh ( sprite ) spell . update_func = function ( self , dt ) --- Gets the next tile in the specified direction. --- If that tile is out of bounds, it returns nil local tile = spell : get_tile ( direction , 1 ) if ( tile == nil ) then -- Spell will be erased once it reaches the end of the field. spell : erase () return end --- Makes the spell slide to the next tile over a certain number of frames. spell : slide ( tile , frames ( speed ), frames ( 0 ), ActionOrder . Voluntary , nil ) --- Attacks the entities this spell collides with. self : get_current_tile (): attack_entities ( self ) end spell . attack_func = function ( self , other ) -- Erases the spell once it hits something create_hit_effect ( spell : get_field (), spell : get_current_tile (), HIT_TEXTURE , HIT_ANIM_PATH , \"8\" , HIT_SOUND ) spell : erase () end spell . delete_func = function ( self ) spell : erase () end spell . battle_end_func = function ( self ) spell : erase () end --- Function that decides whether or not this spell is allowed --- to move to a certain tile. This is automatically called for --- functions such as slide and teleport. --- In this case since it always returns true, it can move over --- any tile. spell . can_move_to_func = function ( tile ) return true end user : get_field (): spawn ( spell , tile ) return spell end","title":"Create Tornado Function"},{"location":"cards/#create-hit-effect-function","text":"Lastly, for BN accuracy, we have the hit effect function. This spawns an artifact, which is a sort of texture and animation that does not interact with entities. Most spells have an impact effect, which is what this function is doing. --- create hit effect. ---@param field any #A field to spawn the effect on ---@param tile Tile tile to spawn effect on ---@param hit_texture any Texture hit effect. (Engine.load_texture) ---@param hit_anim_path any The animation file path ---@param hit_anim_state any The hit animation to play ---@param sfx any Audio # Audio object to play ---@return any returns the hit fx function create_hit_effect ( field , tile , hit_texture , hit_anim_path , hit_anim_state , sfx ) -- Create artifact, artifacts do not have hitboxes and are used mostly for special effects local hitfx = Battle . Artifact . new () hitfx : set_texture ( hit_texture , true ) -- This will randomize the position of the effect a bit. hitfx : set_offset ( math.random ( - 25 , 25 ), math.random ( - 25 , 25 )) local hitfx_sprite = hitfx : sprite () hitfx_sprite : set_layer ( - 3 ) local hitfx_anim = hitfx : get_animation () hitfx_anim : load ( hit_anim_path ) hitfx_anim : set_state ( hit_anim_state ) hitfx_anim : refresh ( hitfx_sprite ) hitfx_anim : on_frame ( 1 , function () Engine . play_audio ( sfx , AudioPriority . Highest ) end ) hitfx_anim : on_complete ( function () hitfx : erase () end ) field : spawn ( hitfx , tile ) return hitfx end","title":"Create Hit Effect Function"},{"location":"cards/#next-steps","text":"Now that you have some familiarity with how a chip is laid out, the possiblities are endless. Want to make a fire tornado with 120 damage? Want to throw a totally new custom spell? If you can create the art for it, now you can!","title":"Next Steps"},{"location":"enemies1/","text":"Package Setup Welcome to the enemies tutorial. In this tutorial we will be showing how the bunny enemy is made. Below is the layout of the mod. (image and sound resources excluded.) Project Layout Bunny/ battle_helpers.lua # Additional helper class for bunny. character.lua # Main lua for all Bunny code entry.lua # Entry lua for Bunny V1/SP/NM ZapRing/ entry.lua # ZapRing code MegaBunny/ entry.lua # Entry lua for MegaBunny variation TuffBunny/ entry.lua # Entry lua for TuffBunny variation entry.lua # Main entry for the mod Note This project layout is not a requirement, but I have done this for the sake of keeping the lines of code in each file down. Most of the code is contained in the Bunny folder. The other forms simply reference bunny. Package entry.lua The entry.lua in the base folder is the code that will first be run whenever the package is loaded. It is fairly simple. Require Scripts entry.lua --ID of the package local package_id = \"com.louise.Bunny\" -- prefix of the character id local character_id = \"com.louise.enemy.\" function package_requires_scripts () --Define characters here. Engine . define_character ( character_id .. \"Bunny\" , _modpath .. \"Bunny\" ) Engine . define_character ( character_id .. \"TuffBunny\" , _modpath .. \"TuffBunny\" ) Engine . define_character ( character_id .. \"MegaBunny\" , _modpath .. \"MegaBunny\" ) end First, we define the ID of the package and a character prefix. Like all mods, the package needs to have a unique ID as well as each of the enemies. A combination of your username and the enemy name should work here. Engine . define_character ( id , directory ) In this case, we have defined the prefix \"com.louise.enemy.\" above, and this is appended with \"Bunny\" through the use of the \"..\" operator. The directory we will have the Bunny code is named \"Bunny\", which is why we have _modpath .. \"Bunny\" . The engine will expect another entry.lua file in that directory. Note We have defined multiple packages here as the name of the enemy changes for each version. In the current build of ONB, enemies with different names need separate packages. Package Init --package init. function package_init ( package ) package : declare_package_id ( package_id ) package : set_name ( \"Bunny\" ) package : set_description ( \"Bn3 Bunny\" ) package : set_speed ( 1 ) package : set_attack ( 15 ) package : set_health ( 40 ) package : set_preview_texture_path ( _modpath .. \"preview.png\" ) end The code under package_init directly corresponds with what is shown on the MobSelect screen. As of now, this is only for display purposes and the values set here have no actual effect on the HP of the mob, etc. Package build function package_build ( mob ) local spawner = mob : create_spawner ( character_id .. \"Bunny\" , Rank . V1 ) spawner : spawn_at ( 4 , 1 ) local spawner = mob : create_spawner ( character_id .. \"Bunny\" , Rank . SP ) spawner : spawn_at ( 5 , 2 ) end Lastly we have package_build which sets up the battlefield for you in mobselect. The possible ranks available are V1-V3, Rare1/2, SP, and NM, but it is up to the mod maker to provide support for the versions. Note: If we wanted to spawn V2, V3 versions, since they have separate packages, you would substitute TuffBunny, Rank.V1 or MegaBunny, Rank.V1.","title":"Package Setup"},{"location":"enemies1/#package-setup","text":"Welcome to the enemies tutorial. In this tutorial we will be showing how the bunny enemy is made. Below is the layout of the mod. (image and sound resources excluded.) Project Layout Bunny/ battle_helpers.lua # Additional helper class for bunny. character.lua # Main lua for all Bunny code entry.lua # Entry lua for Bunny V1/SP/NM ZapRing/ entry.lua # ZapRing code MegaBunny/ entry.lua # Entry lua for MegaBunny variation TuffBunny/ entry.lua # Entry lua for TuffBunny variation entry.lua # Main entry for the mod Note This project layout is not a requirement, but I have done this for the sake of keeping the lines of code in each file down. Most of the code is contained in the Bunny folder. The other forms simply reference bunny.","title":"Package Setup"},{"location":"enemies1/#package-entrylua","text":"The entry.lua in the base folder is the code that will first be run whenever the package is loaded. It is fairly simple.","title":"Package entry.lua"},{"location":"enemies1/#require-scripts","text":"entry.lua --ID of the package local package_id = \"com.louise.Bunny\" -- prefix of the character id local character_id = \"com.louise.enemy.\" function package_requires_scripts () --Define characters here. Engine . define_character ( character_id .. \"Bunny\" , _modpath .. \"Bunny\" ) Engine . define_character ( character_id .. \"TuffBunny\" , _modpath .. \"TuffBunny\" ) Engine . define_character ( character_id .. \"MegaBunny\" , _modpath .. \"MegaBunny\" ) end First, we define the ID of the package and a character prefix. Like all mods, the package needs to have a unique ID as well as each of the enemies. A combination of your username and the enemy name should work here. Engine . define_character ( id , directory ) In this case, we have defined the prefix \"com.louise.enemy.\" above, and this is appended with \"Bunny\" through the use of the \"..\" operator. The directory we will have the Bunny code is named \"Bunny\", which is why we have _modpath .. \"Bunny\" . The engine will expect another entry.lua file in that directory. Note We have defined multiple packages here as the name of the enemy changes for each version. In the current build of ONB, enemies with different names need separate packages.","title":"Require Scripts"},{"location":"enemies1/#package-init","text":"--package init. function package_init ( package ) package : declare_package_id ( package_id ) package : set_name ( \"Bunny\" ) package : set_description ( \"Bn3 Bunny\" ) package : set_speed ( 1 ) package : set_attack ( 15 ) package : set_health ( 40 ) package : set_preview_texture_path ( _modpath .. \"preview.png\" ) end The code under package_init directly corresponds with what is shown on the MobSelect screen. As of now, this is only for display purposes and the values set here have no actual effect on the HP of the mob, etc.","title":"Package Init"},{"location":"enemies1/#package-build","text":"function package_build ( mob ) local spawner = mob : create_spawner ( character_id .. \"Bunny\" , Rank . V1 ) spawner : spawn_at ( 4 , 1 ) local spawner = mob : create_spawner ( character_id .. \"Bunny\" , Rank . SP ) spawner : spawn_at ( 5 , 2 ) end Lastly we have package_build which sets up the battlefield for you in mobselect. The possible ranks available are V1-V3, Rare1/2, SP, and NM, but it is up to the mod maker to provide support for the versions. Note: If we wanted to spawn V2, V3 versions, since they have separate packages, you would substitute TuffBunny, Rank.V1 or MegaBunny, Rank.V1.","title":"Package build"},{"location":"enemies2/","text":"Characters' entry.lua Next, navigate to the bunny folder and open entry.lua. In this file, enemy properties will be specified. local shared_package_init = include ( \"./character.lua\" ) function package_init ( character ) local character_info = { name = \"Bunny\" , hp = 40 , damage = 15 , palette = _folderpath .. \"V1.png\" , height = 44 , frames_between_actions = 34 , fast_hop_frames = 4 , } if character : get_rank () == Rank . SP then character_info . hp = 220 character_info . damage = 150 character_info . palette = _folderpath .. \"SP.png\" character_info . frames_between_actions = 14 character_info . fast_hop_frames = 4 end if character : get_rank () == Rank . NM then character_info . damage = 250 character_info . palette = _folderpath .. \"NM.png\" character_info . hp = 500 character_info . frames_between_actions = 8 character_info . fast_hop_frames = 2 end shared_package_init ( character , character_info ) end This code defines some base properties that will be used later on in the file character.lua Some of these properties like name and hp may be self explanatory, but other properties may be specific to bunny and we'll need to check out the package init to see how these properties are used. Note The rank of the character is being retrieved by using character:get_rank(). This allows us to define different values for other ranks of enemies, such as increased hp/damage/speed, different palettes, etc. If you had a character that does not change name, you could have defined all of the versions here. If you look at TuffBunny/entry.lua and MegaBunny/entry.lua you'll see very similar code, minus the extra versions info. All of them import ../Bunny/character.lua , which will be covered in part 3.","title":"Characters' entry.lua"},{"location":"enemies2/#characters-entrylua","text":"Next, navigate to the bunny folder and open entry.lua. In this file, enemy properties will be specified. local shared_package_init = include ( \"./character.lua\" ) function package_init ( character ) local character_info = { name = \"Bunny\" , hp = 40 , damage = 15 , palette = _folderpath .. \"V1.png\" , height = 44 , frames_between_actions = 34 , fast_hop_frames = 4 , } if character : get_rank () == Rank . SP then character_info . hp = 220 character_info . damage = 150 character_info . palette = _folderpath .. \"SP.png\" character_info . frames_between_actions = 14 character_info . fast_hop_frames = 4 end if character : get_rank () == Rank . NM then character_info . damage = 250 character_info . palette = _folderpath .. \"NM.png\" character_info . hp = 500 character_info . frames_between_actions = 8 character_info . fast_hop_frames = 2 end shared_package_init ( character , character_info ) end This code defines some base properties that will be used later on in the file character.lua Some of these properties like name and hp may be self explanatory, but other properties may be specific to bunny and we'll need to check out the package init to see how these properties are used. Note The rank of the character is being retrieved by using character:get_rank(). This allows us to define different values for other ranks of enemies, such as increased hp/damage/speed, different palettes, etc. If you had a character that does not change name, you could have defined all of the versions here. If you look at TuffBunny/entry.lua and MegaBunny/entry.lua you'll see very similar code, minus the extra versions info. All of them import ../Bunny/character.lua , which will be covered in part 3.","title":"Characters' entry.lua"},{"location":"enemies3/","text":"Character.lua Character.lua -- Includes local battle_helpers = include ( \"battle_helpers.lua\" ) local zapring = include ( \"ZapRing/entry.lua\" ) -- Animations and Textures local CHARACTER_ANIMATION = _folderpath .. \"battle.animation\" local CHARACTER_TEXTURE = Engine . load_texture ( _folderpath .. \"battle.greyscaled.png\" ) local TELEPORT_TEXTURE = Engine . load_texture ( _folderpath .. \"teleport.png\" ) local TELEPORT_ANIM = _folderpath .. \"teleport.animation\" --possible states for character local states = { DEFAULT = 1 , SEEK = 2 , ATTACK = 3 } As always we'll start the file with any resources that we need. We'll also include two additional lua files, battle_helpers.lua and ZapRing.lua which contain code that will be needed. We will also define the three states bunny can be in. More on that later. Package init Next, we'll use the character_info that we defined in entry.lua and apply it to the entity. Self is a reference to the actual entity, so this is where the engine actually sets up those properties through the use of set functions such as self:set_name, self:set_health, etc. In cases such as self.frames_between_actions = character_info.frames_between_actions, this is just assigning a variable to be used later on in the script. -- Load character resources ---@param self Entity function package_init ( self , character_info ) -- Required function, main package information local base_animation_path = CHARACTER_ANIMATION self : set_texture ( CHARACTER_TEXTURE ) self . animation = self : get_animation () self . animation : load ( base_animation_path ) -- Load extra resources -- Set up character meta -- Common Properties self : set_name ( character_info . name ) self : set_health ( character_info . hp ) self : set_height ( character_info . height ) self : set_palette ( Engine . load_texture ( character_info . palette )) self . damage = ( character_info . damage ) -- Bunny Specific self . fast_hop_frames = ( character_info . fast_hop_frames ) self . frames_between_actions = character_info . frames_between_actions self : set_element ( Element . Elec ) --Other Setup self : set_explosion_behavior ( 4 , 1 , false ) self . animation : set_state ( \"SPAWN\" ) self . frame_counter = 0 self . started = false self . defense = Battle . DefenseVirusBody . new () self : add_defense_rule ( self . defense ) self . move_counter = 0 update_func To better understand the rest of the code, lets skip to the bottom and look at update_func. --utility to set the update state, and reset frame counter ---@param state number self . set_state = function ( state ) self . state = state self . frame_counter = 0 end -- stores the state functions local actions = { [ 1 ] = self . action_default , [ 2 ] = self . action_seek , [ 3 ] = self . action_attack } self . update_func = function () -- count frames self . frame_counter = self . frame_counter + 1 if not self . started then self . started = true -- set initial state to default. self . set_state ( states . DEFAULT ) else -- get and call the function for currrent state local action_func = actions [ self . state ] action_func ( self . frame_counter ) end end end Update func is code that runs on each frame that the game runs. (A frame is about 1/60 of a second.) To better organize the code, I have split the code into three functions that will run depending on the state of Bunny. Due to the behavior of Bunny, three states are needed. Default: The bunny is hopping around Seek: The bunny is moving faster and seeking the enemy Attack: Bunny throwing a zapring to attack. Based on certain conditions the bunny will automatically transition between these states. The update functions for each states are stored in the actions table, so the correct function for the current state is always called. We also pass in a frame counter to the function. todo: explain code in states explain battle_helpers explain zapring","title":"Character.lua"},{"location":"enemies3/#characterlua","text":"Character.lua -- Includes local battle_helpers = include ( \"battle_helpers.lua\" ) local zapring = include ( \"ZapRing/entry.lua\" ) -- Animations and Textures local CHARACTER_ANIMATION = _folderpath .. \"battle.animation\" local CHARACTER_TEXTURE = Engine . load_texture ( _folderpath .. \"battle.greyscaled.png\" ) local TELEPORT_TEXTURE = Engine . load_texture ( _folderpath .. \"teleport.png\" ) local TELEPORT_ANIM = _folderpath .. \"teleport.animation\" --possible states for character local states = { DEFAULT = 1 , SEEK = 2 , ATTACK = 3 } As always we'll start the file with any resources that we need. We'll also include two additional lua files, battle_helpers.lua and ZapRing.lua which contain code that will be needed. We will also define the three states bunny can be in. More on that later.","title":"Character.lua"},{"location":"enemies3/#package-init","text":"Next, we'll use the character_info that we defined in entry.lua and apply it to the entity. Self is a reference to the actual entity, so this is where the engine actually sets up those properties through the use of set functions such as self:set_name, self:set_health, etc. In cases such as self.frames_between_actions = character_info.frames_between_actions, this is just assigning a variable to be used later on in the script. -- Load character resources ---@param self Entity function package_init ( self , character_info ) -- Required function, main package information local base_animation_path = CHARACTER_ANIMATION self : set_texture ( CHARACTER_TEXTURE ) self . animation = self : get_animation () self . animation : load ( base_animation_path ) -- Load extra resources -- Set up character meta -- Common Properties self : set_name ( character_info . name ) self : set_health ( character_info . hp ) self : set_height ( character_info . height ) self : set_palette ( Engine . load_texture ( character_info . palette )) self . damage = ( character_info . damage ) -- Bunny Specific self . fast_hop_frames = ( character_info . fast_hop_frames ) self . frames_between_actions = character_info . frames_between_actions self : set_element ( Element . Elec ) --Other Setup self : set_explosion_behavior ( 4 , 1 , false ) self . animation : set_state ( \"SPAWN\" ) self . frame_counter = 0 self . started = false self . defense = Battle . DefenseVirusBody . new () self : add_defense_rule ( self . defense ) self . move_counter = 0","title":"Package init"},{"location":"enemies3/#update_func","text":"To better understand the rest of the code, lets skip to the bottom and look at update_func. --utility to set the update state, and reset frame counter ---@param state number self . set_state = function ( state ) self . state = state self . frame_counter = 0 end -- stores the state functions local actions = { [ 1 ] = self . action_default , [ 2 ] = self . action_seek , [ 3 ] = self . action_attack } self . update_func = function () -- count frames self . frame_counter = self . frame_counter + 1 if not self . started then self . started = true -- set initial state to default. self . set_state ( states . DEFAULT ) else -- get and call the function for currrent state local action_func = actions [ self . state ] action_func ( self . frame_counter ) end end end Update func is code that runs on each frame that the game runs. (A frame is about 1/60 of a second.) To better organize the code, I have split the code into three functions that will run depending on the state of Bunny. Due to the behavior of Bunny, three states are needed. Default: The bunny is hopping around Seek: The bunny is moving faster and seeking the enemy Attack: Bunny throwing a zapring to attack. Based on certain conditions the bunny will automatically transition between these states. The update functions for each states are stored in the actions table, so the correct function for the current state is always called. We also pass in a frame counter to the function.","title":"update_func"},{"location":"enemies3/#todo","text":"explain code in states explain battle_helpers explain zapring","title":"todo:"},{"location":"players/","text":"Under Construction, for now look at Destroyed and Konsts' Guide!","title":"Players"}]}